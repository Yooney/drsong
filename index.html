<html><head><meta charset="utf-8"><script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script><script>// More API functions here:
    // https://github.com/googlecreativelab/teachablemachine-community/tree/master/libraries/image

    // the link to your model provided by Teachable Machine export panel
    const URL = "./my_model/";

    let model, webcam, labelContainer, maxPredictions;

    // Load the image model and setup the webcam
    async function init() {
        const modelURL = URL + "model.json";
        const metadataURL = URL + "metadata.json";

        // load the model and metadata
        // Refer to tmImage.loadFromFiles() in the API to support files from a file picker
        // or files from your local hard drive
        // Note: the pose library adds "tmImage" object to your window (window.tmImage)
        model = await tmImage.load(modelURL, metadataURL);
        maxPredictions = model.getTotalClasses();

        // Convenience function to setup a webcam
        const flip = true; // whether to flip the webcam
        webcam = new tmImage.Webcam(600, 400, flip); // width, height, flip
        await webcam.setup(); // request access to the webcam
        await webcam.play();
        window.requestAnimationFrame(loop);

        // append elements to the DOM
        document.getElementById("webcam-container").appendChild(webcam.canvas);
        labelContainer = document.getElementById("label-container");
        for (let i = 0; i < maxPredictions; i++) { // and class labels
            labelContainer.appendChild(document.createElement("p"));
        }
    }
    async function loop() {
        webcam.update(); // update the webcam frame
        await predict();
        window.requestAnimationFrame(loop);
    }

    // run the webcam image through the image model
    async function predict() {
        // predict can take in an image, video or canvas html element
        const prediction = await model.predict(webcam.canvas);
        var a0 = '바이러스지대'
        var b0 = '메탄지대'
        var c0 = '화석지대'
        var d0 = '탄저균바이러스'
        var e0 = '메탄하이드레이트'
        var f0 = '매머드화석'
        var a = document.getElementById("myAudioA")
        var b = document.getElementById("myAudioB")
        var c = document.getElementById("myAudioC")
        var d = document.getElementById("myAudioD")
        var e = document.getElementById("myAudioE")
        var f = document.getElementById("myAudioF")

        for (let i = 0; i < maxPredictions; i++) {
            //console.log(prediction[i].probability.toFixed(2) * 100)
            //console.log((prediction[i].probability.toFixed(2) * 100) > 90)
            //console.log(prediction[i].className)
            //console.log(prediction[i].className == a0)
            //console.log(typeof prediction[i].className);
            //console.log(prediction[i].className.length)
            //console.log(a0.length)

            if (prediction[i].className == a0 && (prediction[i].probability.toFixed(2) * 100) > 99)
            {
                b.pause()
                b.currentTime = 0
                c.pause()
                c.currentTime = 0
                d.pause()
                d.currentTime = 0
                e.pause()
                e.currentTime = 0
                f.pause()
                f.currentTime = 0
                a.currentTIme = 0
                a.play()
            }
            if (prediction[i].className == b0 && (prediction[i].probability.toFixed(2) * 100) > 99)
            {
                a.pause()
                a.currentTime = 0
                c.pause()
                c.currentTime = 0
                d.pause()
                d.currentTime = 0
                e.pause()
                e.currentTime = 0
                f.pause()
                f.currentTime = 0
                b.currentTIme = 0
                b.play()
            }
            if (prediction[i].className == c0 && (prediction[i].probability.toFixed(2) * 100) > 99)
            {
                b.pause()
                b.currentTime = 0
                a.pause()
                a.currentTime = 0
                d.pause()
                d.currentTime = 0
                e.pause()
                e.currentTime = 0
                f.pause()
                f.currentTime = 0
                c.currentTIme = 0
                c.play()
            }
            if (prediction[i].className == d0 && (prediction[i].probability.toFixed(2) * 100) > 99)
            {
                b.pause()
                b.currentTime = 0
                c.pause()
                c.currentTime = 0
                a.pause()
                a.currentTime = 0
                e.pause()
                e.currentTime = 0
                f.pause()
                f.currentTime = 0
                d.currentTIme = 0
                d.play()
            }
            if (prediction[i].className == e0 && (prediction[i].probability.toFixed(2) * 100) > 99)
            {
                b.pause()
                b.currentTime = 0
                c.pause()
                c.currentTime = 0
                d.pause()
                d.currentTime = 0
                a.pause()
                a.currentTime = 0
                f.pause()
                f.currentTime = 0
                e.currentTIme = 0
                e.play()
            }
            if (prediction[i].className == f0 && (prediction[i].probability.toFixed(2) * 100) > 99)
            {
                b.pause()
                b.currentTime = 0
                c.pause()
                c.currentTime = 0
                d.pause()
                d.currentTime = 0
                e.pause()
                e.currentTime = 0
                a.pause()
                a.currentTime = 0
                f.currentTIme = 0
                f.play()
            }
            

            const classPrediction =
                prediction[i].className + ": " + prediction[i].probability.toFixed(2) * 100 + "%";
            labelContainer.childNodes[i].innerHTML = classPrediction;
        }
    }</script><style></style><script defer="defer" src="/js/chunk-vendors.41a7c4ca.js"></script><script defer="defer" src="/js/app.e9e86932.js"></script><link href="/css/app.2cf79ad6.css" rel="stylesheet"></head><body><audio id="myAudioA"><source src="https://yooney.github.io/drsong/a.mp3" type="audio/mpeg"></audio><audio id="myAudioB"><source src="https://yooney.github.io/drsong/b.mp3" type="audio/mpeg"></audio><audio id="myAudioC"><source src="https://yooney.github.io/drsong/c.mp3" type="audio/mpeg"></audio><audio id="myAudioD"><source src="https://yooney.github.io/drsong/d.mp3" type="audio/mpeg"></audio><audio id="myAudioE"><source src="https://yooney.github.io/drsong/e.mp3" type="audio/mpeg"></audio><audio id="myAudioF"><source src="https://yooney.github.io/drsong/f.mp3" type="audio/mpeg"></audio><div><center><font size="5"><h1>기후위기</h1></font></center></div><div><center><font size="2"><h1>위기의 영구동토층을 구하라</h1></font></center></div><button type="button" onclick="init()" style="float: right;">알아보기</button><center><div id="webcam-container"></div></center><center><div id="label-container"><p></p></div></center></body></html>